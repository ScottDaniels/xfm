
.cc 5
.h1 Commands
The following paragraphs describe the majority of &x commands. 
Following the major &ital(Commands) section, are sections that describe the remainder of
the commands which are used for more complicated actions such as the generation
of lists, tables, and the creation and management of macros.
.sp

Command syntax is given only for the commands which accept parameters. If
no syntax is given with the command description, then the command
does not accept any parameters and the token immediately following the
command string is taken to be text or another command.
It is assumed that any distance parameters (e.g. widths, lengths, or sizes)
can all have a &cw(p,) a &cw(c,) or an &cw(i) appended to the value
to indicate points, centimeters.
In the examples &cw( <dist> ) is used to indicate a numeric value which 
is assumed to have one of these characters appended (e.g. 1.2i 3c).


.h2 Formatting Control
The overall goal of &x is to read document tokens from the source and to 
place them into the output using any formatting controls (justification, 
centering, font, line and column lengths, etc.) which have been set. 
There are times when formatting needs to be disabled (e.g. when including 
a bit of programme which must have its syntax preserved), and as such there
are mechanisms to start and stop formatting, and to include information 
from the source directly &ital( as is. )
The following are the three commands used to enable and disable formatting.

.h3 Starting/Stopping Formatting
The format command &(fo) can be used to turn formatting off or on.  
The command accepts an optional parameter of either &cw( off ) or &cw( on )
which sets the obvious mode.  
If the parameter is omitted, &cw( on ) is assumed.
When formatting is off, tokens are placed from the source as they appear
with respect to line breaks and spacing (tab characters result in just a single space).
The font and text size settings which were in effect at the time formatting 
was stopped are used. 
Any special characters, with respect to the output format (HTML or Postscript)
are properly escaped when placed into the output document even when formatting is off.

.sp
When formatting is off, macro and variable expansion does not happen unless
the macro is placed in the first column; this allows a macro to be used 
to restart formatting. 
Command interpretation when formatting is off is also ignored except when the 
command begins in the first column.  
Care must be taken when using commands when formatting is off.

.gv figure
Figure &_fig illustrates how turning off formatting can be used to include 
an example of source code into a document.
.sp .5
.cc 10
.st [ &textsize 2 - ]
.sf &cwfont
.nf
  .sf Courier
  .fo off
    for  i := range list  {
      list[i].print( display )
    }
  .fo on
  .sf Times-Roman
  .fg Code to print a list of things.
.fo
.sf &textfont
.st &textsize
.fg Using no format to insert a source code example into a document.
.sp

The code segment first sets the font to a constant width font (courier) and
then turns formatting off. 
The lines of input until the format command is reached are placed into the output
without any modification.
After the example text, formatting is turned on, and then the text font is reset 
to a proportional font and a figure caption is added.

.h3 No Format Command
The no format command &c(nf) was a part of the initial &x implementation when 
part of its goal was to emulate the DCF script language. 
The command has the exact same effect as &cw( ^.fo off ) and it takes no 
parameters. 

.h3 Add Text 'as is'
The as is command &c(ai) causes all lines in the source file until a
&ital(format command) is encountered to be placed into the output file exactly
as is.  While this command is similar to the  &ital(no format) command, when
processing as is text, &x makes no attempt to escape characters that
have special meaning in the output file (e.g. parenthesis when generating
PostScript, or greater-than symbols when generating HTML). The as is
command is generally used when including native PostScript, or
HTML into the document.

.h3 Justifying Text
When text justification is turned on with the &ital(justify) &c(ju) command,
&x will attempt to format text such that the last character of each line
is flush with the right margin.  Justification is actively attempted by &x
when generating PostScript and plain text, meaning that &x is actually calculating
the spacing and making the adjustments to align the text. 
When generating HTML output, &x allows the file to be created such that the
browser that displays the HTML is responsible for text formatting, and
as a justification tag is not defined in HTML, justification is not possible
when generating HTML documents.
.sp

The &ital(justify) command accepts either an &cw(on) or &cw(off) parameter
to cause &x to start or stop producing justified text.
.sp
.sf &cwfont
.st [ &textsize 2 - ]
.nf
   .ju {on | off}
.fo
.sf &textfont
.st &textsize
.sp

.h3 Centering A Text Segment
A single text segment may be centered on the current output line using
the center command &c(ce.)
The current output buffer is flushed and any text placed after the &ital(center)
command and before the next newline character will be centered between the current margins.
(See the block center &c(bc) command.)
.sp

.h3 Block Center
The block center command &c(bc) is used to start or end a block of text that
should be centered on the page. All source text between the two block center
commands is formatted and the output lines are centered between the margins.
The syntax for the block center command is:
.sp
.sf &cwfont
.st [ &textsize 2 - ]
.nf
   .bc {start|stop}
.fo
.sf &textfont
.st &textsize
.sp

.h2 Setting The Font And Font Size
The &ital(set font) &c(sf) command is used to set the font type for all document types
except plain text. The command accepts the name of the font that is to be established
as the current font for all formatted text until the next &ital(set font) command
is encountered.
As font names differ between the different output types, it is strongly recommended
that font name variables, (e.g. textfont, italfont, boldfont) be created and defined
based on the formatter type at the beginning of the document source.

.sp
.gv fig
.dv font_fig &_fig
The &ital(set textsize) &c(st) command is used to set the size of the current font.
The command accepts one parameter which is the font size (in points) to be used.
In figure &font_fig the &ital(set font) and &ital(set textsize) commands
are illustrated along with examples of defining two kinds of &ital(bold) macros.
.sp

.** -----------------------------------------------------------------------------
.ca start font_examp.ca
.cc 22
.** .bx start m
.st [ &textsize 2 - ]
.sf &cwfont
.nf

 .if hfm
   .dv textfont arial
   .dv startbold ^<b^>
   .dv endbold ^</b^>
   .dv bold ^<b^>$1^</b^>
   .dv textsize 12
 .ei
  .if pfm
    .dv textfont Helvetica
    .dv startbold .sf Helvetica-Bold
    .dv endbold   .sf ^&textfont
    .dv bold .sf Helvetica-Bold $1 .sf ^&textfont
    .dv textsize 10
     .fi
 .fi
 .sf &textfont
 .st &textsize
.fo
.** .bx end
.sf &textfont
.st &textsize
.fg The textsize and font commands.
.sp 1
.ca end
.** ------------------------------------------------------------------------------
&ifroom(22:font_examp.ca)

.sp

.h3 Smashing things together
By default, tokens placed into the output are separated by a single space, however there
are times where the input source requires spacing, but the spacing is not desired in
the output. 
The smash command &c(sm) causes &x to eliminate the intervening space 'smashing' the
tokens on either side of the command together. 
A common use is to add a superscript to the previous word which is illustrated in the 
&ital(temporary font changes) section below.

.h3 Temporary font changes
For short font changes (e.g. to set a few words in bold face), the temporary font
command, &c(tf) can be used.
This command accepts a font name, size, and then renders all tokens up to the end of the
line (or lone colon) in that font. 
When the end is reached, the previous font is resumed.
A special font name, &cw(superscript) is recognised and the font size can be of the
form &cw(/n) or &cw(m/n) to divide the current font size by n, or to multiply the
current font size by m/n allowing the superscript to be proportional to the current
font size. 
This allows for macros such as ^&ital() or ^&bold() as illustrated below:
.sp .5

.sf &cwfont
.st [ &textsize 2 - ]
.st 8
.nf
  .dv ital .sm .tf &italfont &textsize $1 ^:
  .dv super .sm .tf superscript /2 $1 ^:
  .dv zsuper .sm .tf Dingbats 2/3 $1 ^:
.fo
.sf &textfont
.st &textsize
.sp
Note that the &c(sm) command causes the whitespace to be removed between the last
token placed into the document and the fonted character.

.h2 Abort
The abort command &c(ab) causes &x to stop without writing any additional
'end housekeeping' information to the output file. This can be
used when generating PostScript or HTML that needs to be incorporated
into another similar file without all of the necessary 'cleanup' instructions
and/or tags at the end of the document.

.h2 Line Break
The break command &c(br) causes the next text token encountered in the input source
to be placed at the beginning of a new line.  If the current line is at the bottom of
a column, or page, then the necessary eject is done before continuing to render the
document.

.h2 Enclose Text In A Box
The box command &c(bx) is used to draw boxes around sections of text.
The box command accepts one of two positional parameters such that the syntax of the
command is:
.sp
.st [ &textsize 2 - ]
.sf &cwfont
.nf
 .bx option [m] [c=colour] [b=<pts>] [w=<pctg>]
.fo
.sf &textfont
.st &textsize
.sp
Where:
&indent
.bd .75i &ditext
.di option : Is either the word &cw(start) or &cw(end) to start or end the box.
.sp .4
.di c=colour : Allows the user to select a background colour for the box when generating
HTML output.
.sp .4
.di b=<points> : Allows the user to supply the border width of the box when generating HTML
output.
.sp .4
.di m : Base the box on the current text margins rather than the current column definition
(default).
.sp .4
.di w=<pctg> : Defines the percentage of the browser window that should be used to draw
the box. Valid only when generating HTML output.
.ed
&uindent
.sp

.** --------------------------------------------
All source between the &ital(box start) and &ital(stop) commands is parsed as
expected and when the page is rendered a box is placed round the resulting output text.
Should the text force a column or page eject, the box is "closed" at the bottom and restarted
in the new column.

The following illustrates text formatted in both a box constrained by the margins and by the column:
.sp .5
.cc 8
&indent
.ll -.5i
.bx start m w=100
The command .br 
&cw(^.bx start m w=100) .br 
was used to generate this box with formatted text inside of it.
The 'm' parameter constrains the box to the margin width.
The indention was shifted by .5 inches and the line length reduced by the same to illustrate
how a margin box 'hugs' the current margin settings.
.bx end
.ll +.5i
&uindent
.sp

&indent
.ll -.5i
.bx start  w=100
The command .br
&cw(^.bx start  w=100) .br
was used to generate this box with formatted text inside of it.
The absence of the 'm' parameter constrains the box at the column width.
The margin settings for this text are the same, but with out the 'm' option, the box remains
fixed at the column boundaries.
.bx end
.ll +.5i
&uindent
.fg Output from two different box commands.
.sp

If the text margin is set after a box has been started with the margin option, then the effect
is to add padding inside of the box which has been position using the current margins.
The following code will reduce the margin and line length then start a margin oriented
box  as illustrated above.
Once the box is started the margin and line length are further adjusted to add the padding.
The space command is used to add vertical padding.
.gv figure
Figure &_fig illustrates the source code and figure .ev [ &_fig 1 + ] shows the resulting output.
.sp .5

.cc 10
.ca start box_ex3.ca
  .ll -1i
  .in +.5i
  .bx start m w=100
  .sp .4
  .ll -.5i
  .in +.25i
  Another example of using a margin
  oriented box, this time adding
  additional padding round the text
  that is placed inside of the box.
  Padding is accomplished via a series
  of indent, line length and space
  commands.
  .br
  .in -.25i
  .ll +.5i
  .sp .4
  .bx end
  .in -.5i
  .ll +1i
.ca end

.st [ &textsize 2 - ]
.sf Courier
.nf
.im box_ex3.ca
.fo
.sf &textfont
.st &textsize
.fg Margin oriented box with padding
.sp

.cc 10
.im box_ex3.ca
.fg Output of code from figure &_fig.

.cc 5
.h2 Setting The Bottom Of Page
The bottom &cw(y) value is used by &x to determine the bottom of the page when generating
PostScript documents. The user may adjust the bottom &cw(y) value using the
&ital(bottom Y) command &c(by) which  specifies the distance (in points or inches) from the
top of the page that should be treated as the last usable area for generated text.
The &ital(bottom Y) command has the following syntax:
.sp
.sf &cwfont
.st [ &textsize 2 - ]
.nf
   .by <dist>
.fo
.sf &textfont
.st &textsize
.sp
Where &ital(distance) is the number of points or inches from the top of the page.
It should be noted that any running footer text and/or page numbers are placed below
the value specified.
If &ital(distance) is negative, then it is assumed to be the distance &ital(up) from
the bottom of the page.
The &cw(hfm) generator ignores the bottom &cw(y) command.

.h2 Capturing Source
The capture command &c(ca) allows a section of &x source to be captured and buffered into a
temporary file.
The primary use is to allow an example to be created in-line and included in the document
at the current point if there is enough room on the page, and to defer the inclusion of the
source until the top of the next page if there is not.
An alternative method would be to maintain the example in a separate file; the capture
command allows that to be avoided if it makes more sense.

.sp
The capture command accepts either a &cw(start) or &cw(end) directive;  the name
of the capture file is expected to follow the start directive.
The start directive causes the named file to be opened and all of the lines from the 
source are placed into the file until the end statement is reached. 
The &ital( start ) directive may be replaced with the &ital( extend ) directive which 
will open the target file in append mode.  
The capture end statement (.ca end) &bold( must ) start in column zero. 
.sp 
The capture command supports two additional options which may be supplied on the start (extend) 
command line:

.sp .5
&indent
.bd .75i  Helvetica
.di expand : Causes simple variables (&name) to be expanded when encountered in the source.
.sp .4
.di shift : Causes the leading tab or whitespace character (just one) to be stripped. This 
allows capture commands to be embedded.
.ed
&uindent
.sp 

.gv fig
Figure &_fig contains sample code which demonstrates the capture command.
.sp


.** gotta love it -- using the capture command to doc the capture command :)
.ca start martha.ca
.sf &cwfont
.st [ &textsize 2 -]
.nf
  .** capture the quote, then if enough room
  .** imbed the file now, else put it off
  .** until the next page eject.
  .ca start quote_jones.ca
    .sf Times-Italic
    &indent
    .bx start m
    .sp .5
    On a clear day it might be possible to see
    forever, but the reality is that you are
    only able to see a distance which is
    relative to the height your eyes are above
    the Earth's surface.  For a person six
    feet tall this is probably about three
    miles.
    .sp .5
    Martha Jones
    .sp .5
    .bx end
    .sp 2
  .ca end
  .** ---include the file now if three is room
  .if pfm
     .gv lines
     .if  &_lines 10 >   
        .im quote_jones.ca 
     .ei 
        .oe col .im quote_jones.ca 
     .fi 
  .ei 
     .im quote_jones.ca
  .fi
.fo
.sf &textfont
.st &textsize
.sp .1
&martha_line
.fg Illustration of the capture command.
.sp
.ca end
.gv remain
.if &_lines 34 <
	.dv martha_line .ln
	.oe column .im martha.ca
.ei
	.dv martha_line
	.im martha.ca
.fi


.h2 Column Layout
&x allows one or more columns of text to be placed on a postscript page. 
For most documents, the notion of page oriented management is best done 
as column management (column eject, etc.) so that if the document is converted
from  single column to multiple columns, the resulting output should just be right.
The following paragraphs described the column oriented commands.

.h3 Establishing Multiple Columns
When generating PostScript, output can be organised into multiple columns across each page.
The column definition command &c(cd) is used to indicate the number and size of columns,
indention information, and gutter size (distance between columns) information.
.gv fig
.dv cdfig &_fig
Figure &_fig illustrates a page layout with two column and indicates the various
areas of the page.  The column width, gutter and column indention sizes are all controlled
using the column definition command.  The other areas, header margin, text indention and
line length are controlled using separate commands.

.if false
.** include the pic at the top of the next column
.if pfm
	&ifroom(15:cd.im)
.ei
	.im cd.im
.fi
.fi

.sp

.cc 5
The column definition command has the following syntax:
.sp
.sf &cwfont
.st [ &textsize 2 - ]
.nf
 .cd n [w=width] [g=gwidth] [i=indent]
.fo
.sf &textfont
.st &textsize

.sp
.cc 15
Where:
&indent
.bd .6i &ditext
.di n :  Is the number of columns
.sp .4
.di indent : Is the amount of space
that the left column is to be indented from the edge  of the page.
.sp .4
.di gwidth : Defines the width between columns.
.sp .4
.di width : Supplies the width of each column.
.ed
&uindent

.cc 10
.sp
Until the first column definition command is encountered, &x defaults to a single column
with a width of approximately 7 inches.
If the column definition command causes the column width to be smaller than the currently set
line length, the line length will be set to the same value as the column width. No warning
message is issued if this happens as it is a convenience adjustment made for the user. The
same adjustment is &bold(not) made, if the column width is increased such that it becomes
larger than the line length. 
This command is recognised only by the PostScript formatter.

.h3 Forcing A New Column
The column begin command &c(cb) forces the next text encountered in the source file to
be placed at the start of the next logical column.  If the current column is the last
column on the page, then a page eject will result.
The column begin command accepts no parameters/arguments and is ignored by &cw(hfm.)
When in single column mode, the column begin command is the same as a page eject command.

.h3 Conditional Column Eject
The conditional column eject command &c(cc) allows the user to easily test to determine
if a minimum number of text lines remain in the current column. If the number of text lines
(at the current text size setting) do not remain in the current column, a column eject
is performed. Otherwise, the formatted output continues to be placed in the current
column. 
The syntax of this command is:
.sp
.sf &cwfont
.st [ &textsize 2 - ]
.nf
   .cc n
.fo
.sf &textfont
.st &textsize
.sp
Where &ital(n) is the number of lines that must remain in the current column in order
to continue place formatted output into the column. The conditional column eject command
is ignored by &cw(hfm) and &cw(tfm.)

.h2 Text Colour
The text colour command &c(co) establishes the colour that text should be painted in.
Colours should be supplied as either &cw(#rrggbb) or &cw(0xrrggbb) values.  The hfm
formatter will accept names, but for portability names are not recommended (use macros to define colour names).
The following illustrates the syntax for this command:
.sp
.sf &cwfont
.st [ &textsize 2 - ]
.nf
   .co 0xrrggbb
   .co #rrggbb
.fo
.sf &textfont
.st &textsize
.sp
Where &cw(#rrggbb) is the standard hexadecimal red, green, blue triplet (e.g. ff4c90).

.h3 Setting The Line Length
For all output types except HTML, the length of each text line across a column
is adjusted using the &ital(line length) &c(ll) command.  This command accepts
a size parameter (specified in points, inches or characters) and will set the
line length provided that it is not larger than the current column size.
The length parameter may also be specified as a relative parameter to increase
or decrease the current line length by the size entered.  A relative parameter
begins with either a plus sign (+) or minus sign (-).

.sp
The &ital(indention) &c(in) command is used in conjunction with the &ital(line length)
command to set the amount of space that is placed between the left column edge
and the left margin of the text in the column.  The following code segment
illustrates how a document with two columns (each three and one half inches
wide) can be established.
.sp .5

.** -------------------------- capture ------------------------------
.ca start colwid_examp.ca
.sp
.cc 8
.st [ &textsize 2 - ]
.sf &cwfont
.nf
  .** 1/4 inch space between cols (gutter)
  .cd 2 w=3.5i g=.25i i=.25i	
 
  .** no text indention, linelen same as 
  .** column width
  .in 0i                    
  .ll 3.5i

.fo
.sf &textfont
.st &textsize
.fg Column width and text indention example.
.sp
.ca end
.** ------------------------------------------------------------------
&ifroom(12:colwid_examp.ca)

.sp
Two common macros that are defined in &x source are the &cw(indent)
and the &cw(uindent) macros.  The indent macro adjusts the line
length down a small amount, while increasing the indention
.gv fig
.dv macro_fig &_fig
value by the same amount. For example,  code in figure &macro_fig might be
used to define these macros.
.sp

.** -------------------------- capture -----------------------------
.ca start macros_examp.ca
.sp
.cc 12
.** .bx start  m
    
.st [ &textsize 2 - ]
.sf &cwfont
.nf

   .if hfm
      .dv indent .bl ^:
      .dv uindent .el
   .ei
      .dv indent .br .ll -.5i .in +.5i
      .dv uindent .br .in -.5i .ll +.5i
   .fi

.fo
.sf &textfont
.st &textsize
.** .bx end
.fg Macros for setting the line length and text indention.
.sp 2
.ca end
.** -----------------------------------------------------------------
&ifroom(15:macros_examp.ca)


Note that the order that the indention and line length are changed is important
as if the indention value would cause the line to extend past the defined
column width, and error will occur and no adjustment will be made.
Even though there is no concept of line length in an HTML document, indention
can be simulated by starting an ordinary list as most browsers will automatically
indent the text while 'inside'  of a list.

.h2 Source Comments
The comment command &c(**) causes all text tokens encountered after the command, up to
the next newline character, to be ignored.
&x can be instructed to ignore multiple source lines, effectively commenting them out, by
enclosing the undesired lines of source inside of a conditional expression that is guaranteed
to evaluate to false (e.g. ^.if false), or by using the jump &(jm) command.
Care must be taken when commenting out commands which have embedded single colons as the
parameter parser will treat the first one as a pseudo newline.

.h2 End And Column Notes
A column note (foot note) can be added to the bottom of the current column by reserving an
amount of space and supplying the text that should be placed there when the end of the column
is reached. 
The column note command &c(cn) is used to define this space and add the text to a cache
which is then written later.
Column notes are usually denoted in the text with a superscripted number or symbol which is
also given to the column note command.
The syntax is:

.sp .5
.sf &cwfont
.st [ &textsize 2 - ]
.st 8p
.nf
   .cn start {atbot|atclose} [s=sym]
       <font-name> <font-size> <space>
   .cn end
.fo
.sf &textfont
.st &textsize
.sp
Where:
&indent
.bd .75i &ditext
.di atbot : indicates that the note is to be placed at the bottom of the current column.
.sp .4
.di atclose : indicates that the note is to be placed at the end of the document.
.sp .4
.di sym : is the symbol to use; if omitted an internal counter is used and the note
  is assigned to the text.
.sp .4
.di font : is the name of the font that the note text will be written in.
.sp .4
.di size : is the font size (e.g. 8p) that the note is to be written in.
.sp .4
.di space : is the amount of space that needs to be reserved at the end for the note.
.sp
.ed
&uindent

.sp
The note text is placed between the start and end commands.
When using at close column notes, a &ital(show) command will need to be issued which
causes the end notes to be added to the output.


.h2 Conditional Page Eject
Similar to the &ital(conditional column eject) &c(cc) command, the
&ital(conditional page eject)
&c(cp) command causes a page eject if the indicated number of lines do not remain on
the current page. While this command is still supported, it is not recommended as
it does not take into account the number of columns which are being placed onto the page
and thus may not yield the desired results.
The &ital(conditional column eject) command can be used in place of this command and
will generate the expected results regardless of the number of columns that are being
formatted.


.h2 Double Space Mode
The double space command &c(ds) causes the formatted output to be
rendered with twice the space between lines than when in
normal mode.
This command requires no parameters.
The &ital(single space) &c(ss) command returns the document formatting
to single space mode. It too requires no parameters.

.h2 Define Variable
&x supports the definition of variables with the &ital(define variable) &c(dv)
command. Variables can be assigned commands, text, or a combination
of commands and text. In their simplest form, a variable allows the user
to make their document easier to maintain in the same fashion as a programmer
would use a variable or constant in their code. For example, the
source code for this document has the variable &cw(x) defined to expand
to &cw(XFM) rendered in an italic font. Other variables, such as an
&cw(indent) variable can be defined to make indenting text easier.
Macros are the most complex variables that are supported by &x and allow
one or more parameters to be inserted into the variable definition as the
variable is expanded. Macros will be explained in a separate section of
this document.
.sp
The &ital(define variable) command has the simple syntax of:
.sp
.sf &cwfont
.st [ &textsize 2 - ]
.nf
    .dv <var-name> <tokens>
.fo
.sf &textfont
.st &textsize
.sp
Where:
&indent
.bd .75i &ditext
.di var-name : Is the name that the variable is assigned.
.sp .4
.di tokens : Are the "value" that is assigned to the variable.
.ed
&uindent
.sp
Once a variable is created, it may be referenced using the ampersand
(^&) character. Thus to expand the variable &cw(x) the source for
the document would be ^&x for each reference.
.sp

The &ital(show variable) &c(sv) command can be used to show any defined
variable. The &ital(show variable) command accepts the name of the variable
to display or the word &cw(all) as a parameter. The value of the variable,
or all variables if &cw(all) is specified, is written to the standard error
device.  This command is useful when debugging complicated macros.

.sp
.cc 6
The following is a list of several &ital(define variable) commands that are useful:
&indent
.sp 1
.li &cw(^.dv indent ^.br ^.ll -.5i ^.in +.5i)
.br .li &cw(^.dv textsize 10p)
.br .li &cw(^.dv textfont Helvetica)
.br .li &cw(^.dv boldfont Helvetica-Bold)
&uindent
.sp
&x creates a variable which indicates the formatter that is currently processing the document
source. It will often be necessary to initialise the document differently based on the type of
output being generated, and thus any of the following variables may be tested for: &cw(pfm, tfm, hfm)
or &cw(rfm.)

.h2 Conditional Processing
&x supports conditional processing with an &ital(if-else) construct of commands. 
When the if command &c(if) is encountered the remaining tokens on the line are
evaluated and if the result is true then the source lines
until a matching &ital(end if) command &c(fi) or &ital(else)
command &c(ei) are parsed and formatted.
If the tokens are evaluated to a false value, then the source lines are skipped, and the lines
between the else and &ital(end if) are processed (if supplied).
If commands may be nested.

.sp
Tokens are evaluated as either an expression or as variable names.  A variable name evaluates to true
if it is defined (NOT based on the value of the variable). 
Thus if conditional processing is to be done only if the formatter being used is the PostScript formatter
then the following if command could be used (note the token is just the variable name and no
dereferencing ampersand is used):
.sp
.cc 6
&indent
.st [ &textsize 2 - ]
.sf &cwfont
.nf
	.if pfm
		.dv indent .br .ll -.5i .in +.5i :
	.fi
.fo
.sf &textfont
.st &textsize
&uindent
.sp

Variable values may be referenced as parameters on the if command
line, and their values will be interpreted as numbers.
Numbers may be compared using greater than (>), less than (<) and equal (==) operator symbols.

.sp
.gv fig
.dv ifel_fig &_fig
Expressions are evaluated in a reverse polish notation (e.g. &a &b < to evaluate to true if
the variable &ital(a's) value is less than the value of variable &ital(b.)
Expressions may be 'negated' by placing the bang character (!) in front of the
Logical AND and OR operators, ^& and | respectively, can be used and are also applied
in a reverse polish fashion.
Figure &ifel_fig illustrates an example expression which evaluates to true if the variable &ital(a) is
greater than variable &ital(b), or variable &ital(d) is less than &ital(e).
.sp

.** ------------------- capture ---------------------------
.ca start ifelse_examp.ca
.cc 10
.st &cwfont
&indent
.** .bx start m
.sp
.st [ &textsize 2 - ]
.sf &cwfont
.nf
 .if &a &b > &d &e > |
   either a > b, or d > e.
 .ei
   both a < b and d < e.
 .fi
.fo
.sf &textfont
.st &textsize
.** .bx end
&uindent
.st &textfont
.bx end
.fg Using the if-else commands.
.sp 2
.ca end
.** --------------------------------------------------------
&ifroom(16:ifelse_examp.ca)


.sp
The command &cw(^.if 0) and the command &cw(^.if false) always evaluates to &ital(false) and is a
simple way of commenting out a block of the document source.


.h2 Encapsulated PostScript Files
When using the &cw(pfm) formatter to generate PostScript output,
&x is capable of imbedding files that have been saved in encapsulated
PostScript format into the document.  This provides for a simple way
of including drawings or other artwork that is created and saved
as an &cw(.eps) file. The &ital(encapsulated postscript) command
&c(ep) is used to indicate the name of the file to include, and to
define several of the constraints that &x will use to place the
document into the formatted text.
The following is the command syntax for the &ital(encapsulated postscript)
command (broken onto multiple lines for readability):
.sp
.st [ &textsize 2 - ]
.sf &cwfont
.nf
 .ep fname [l=n] [x=n] [noadvy]
       [center|close|proportional|stretch]
.fo
.sf &textfont
.st &textsize
.sp
Where:
&indent
.bd .7i &ditext
.di fname : Is the filename of the encapsulated postscript file.
.sp .4
.di l : Is the length from the current y position to reserve for the drawing.
The value (n) may be postfixed with either an &cw(i) or &cw(p) to indicate
the units of measurements. If neither postfix character is used a unit of
&bold(lines) (at the current text size) is assumed.
.sp .4
.di x : Supplies the number of inches/points to shift the origin of the
drawing to the right. This is sometimes necessary depending on how the
origin as been established by the programme that created the encapsulated
postscript file.
.sp .4
.di center : Specifies that the drawing is to be centered between the current
margin values.
.sp .4
.di close : Causes the &cw(y) value to be shifted toward the top of the page
if the length of the drawing did not require the amount of space reserved
with the &cw(l) parameter.
.sp .4
.di stretch : Causes the drawing to be stretched in order to fill all of the
reserved space. &bold(CAUTION^:) &x may not maintain an &cw(x,y) aspect ratio when stretching
a drawing.
.sp .4
.di prportional : &x will attempt to keep the &cw(x,y) aspect ratio in proportion
to the original drawing.
.sp .4
.di noadvy : Causes the current &cw(y) value &bold(not) to be advanced after the drawing
has been included.  This allows the document text to be placed on top of the drawing and
can be used to place a printed 'water mark' on the page.
.ed
&uindent

.sp
The drawing in Figure &cdfig was created using an external drawing tool, saved as
an encapsulated PostScript file, and included with the following command:
.sp

.st [ &textsize 2 - ]
.sf &cwfont
.nf
 .ep column.eps center l=4i
.fo
.st &textsize
.sf &textfont
.sp
The encapsulated PostScript command is ignored when generating any output other than PostScript, however
drawings (images) can be incorporated into HTML output by causing an image &ital(tag) to be placed into the document.
.gv fig
.dv cond_fig &_fig
Generally this involves a set of conditional code; figure &cond_fig illustrates how it can be done.
Notice that the box code, common to either type of output, is started and ended outside of the
if statement.

.** ----------------------- capture ------------------------------
.ca start cond_example.ca
.sp
.cc 25
.st [ &textsize 2 - ]
.sf &cwfont
.nf
   .bx start m
   .if pfm
      .ep figs/drawing1.eps center l=3i
   .el
      .if hfm
        &image(figs/drawing1.jpg)
      .ei
        .sp
         [IMAGE: figs/drawing1.jpg]
        .sp
     .fi
   .fi
   .bx end

.fo
.sf &textfont
.st &textsize
.fg Sample use of conditional statements.
.fi
.sp 2
.ca end
.** ----------------------------------------------------------------
&ifroom(25:cond_example.ca)


.sp
.h2 Evaluate Expression
&x provides the ability to compute simple values and to include the result as a parameter to any
command. At times, it is quite convenient to have a computed value placed into the document itself
rather than made available as a command. The &ital(evaluate) &c(ev) command allows for the evaluation
of its parameter and then places the result into the document. 

.sp
Expressions in &x are enclosed in square braces ([ and ]) and are interpreted using a stack oriented,
reverse polish notation. Thus all values are stacked until an operator is encountered which operates
on the last &ital(n) values. The number of stacked values operated on  depends on the operation.
The result is always left as the top value on the stack, and when the end of the expression is reached
(the closing square bracket) the top value is used as the parameter value and all other values are
discarded.
.sp
For example, to add two and three together and to place the result into the document
the expression would be:
.sp
.sf &cwfont
.nf
   .ev [ 2 3 + ]
.fo
.sf &textfont
.sp
All calculations are done as double precision
floating point numbers and in addition to the four basic operations (addition, subtraction,
multiplication, and division) several other operations are provided for; their operators are listed below:
.sp
&indent
.bd .5i &ditext
.di	% : Modulo division.
.sp .4
.di 	F[ract] : Take the top value on the stack and replace it with the fraction portion of the value.
.sp .4
.di 	I[nt] : Take the top value on the stack and replace it with the integer portion of the value.
.sp .4
.di 	S[um] : Sum all elements in the stack.
.ed
&uindent
.sp
Expressions may be placed as a parameter to any command that accepts numeric input and to
use an open square bracket as a parameter, it must be escaped. Thus to increase the font size by
two points the following commands could be used:
.sp
.st [ &textsize 2 - ]
.sf &cwfont
.nf
     .gv tsize
     .st [ &_tsize 2 + ]
.fo
.sf &textfont
.st &textsize

.sp
.h2 Figure And Table Captions
The &ital(figure) &c(fg) command is used to title a figure that has been
placed into the output document. All tokens between the &ital(figure) command and
the next newline are taken as figure text and added to the document.
&x automatically places the figure number in front of the figure text, and
reduces the text size slightly.  The current font is used to render the figure
text.
The style of the figure number depends on one of two things:
.sp .5i
&indent
.bl &lic1
.li Whether or not paragraph numbering has been turned on
.li Whether or not the no section in figure command has been issued
.el
&uindent
.sp

When paragraph numbering is off, then figures are labled with a simple ordinal number (e.g. Figure n).. 
If paragraph numbering is turned on, then the figure number consists of the paragraph number of the most recent level one
header number, followed an incremental figure number (e.g. 12-2).
In this mode, the figure number is reset each time a header level one command is encountered.
If paragraph numbering is on, and the command has been invoked with the 'nosect' parameter, then 
the section number will be dropped and they will &bold(not) be reset when a header level one command is processed.
.sp
The font and font size may also be specified on the figure command using the &cw(f=) and &cw(s=) parameters respectively. 
By default, the current text font is used and the font size is reduced by two points provided that the curent 
font size is greater than 8 points.

.sp
The figure command can also be used to label tables.  If the &cw( t=table ) type option is
used, then the word &ital(Table) and the table number is added.
Examples of  the various options:

.sp
.st [ &textsize 2 - ]
.sf &cwfont
.nf
 .** turn of section oriented numbers even 
 .** if paragraph numbering is on.
 .fg nosect
 
 .fg s=10 A figure that has a hard size
 .fg f=Helvetica Figure text with hard font
 .fg An illustration of the wysiwyg-is-bad.
 .fg t=table Counts of users and time.
.fo
.sf &textfont
.st &textsize
.sp





.h2 Getting System Values
.gv table
.dv gv_fig_num &_table
The &ital(get value) &c(gv) command allows some &ital(system) values to
be defined as variables, and thus accessible by the &x source. The
syntax for this command is:
.sp .5
.if pfm
	.oe page .im gv_tab.im
	.sp
.fi

.sf &cwfont
.st [ &textsize 2 - ]
.nf
   .gv value-name
.fo
.sf &textfont
.st &textsize
.sp
Where &cw(value-name) is one of the various system value identifiers that should
be placed into  a parameter. See table &gv_fig_num for a list of &ital(value-names)
and the variables that are created.
Value-names are case sensitive, and generally only the first few characters of the name
are needed on the &ital(get value) command.

.sp

.** include where we really want it if not pfm
.if ! pfm
	.im gv_tab.im
.fi

.sp
All of the variables that are created as a result of the &ital(get variable)
command (with the exception of the get environment form) are named with a
leading under bar character (_) in an attempt to prevent a user variable
from being destroyed.  Thus, it is recommended that user variable names are
not started with a lead under bar character.

.sp

.h2 Paragraph Headers
Four levels of paragraph headers are supported. Automatic header numbering
may be turned on and off using the &ital(header numbering) &c(hn) command.
By default header numbering is turned on, and when turned on figure numbers
are generated with the form <h1>-<n> where &ital( h1 ) is the current header
1 number, and &ital(n) is reset to 1 with each new &c(h1) command.
The values returned by the get value command for figure and table also
reflect this numbering scheme, so the user does not need to track paragraph
numbers to reference them in the text.

.sp
The header commands all have the format:
.sp
.sf &cwfont
.st [ &textsize 2 - ]
.nf
    .h<n> header text
.fo
.sf &textfont
.st &textsize
.sp
Where the <n> is replaced with the header level number 1 through 4 (e.g. h1).
Headers are placed into the formatted document using the header level properties,
set by the &ital(define header) &c(dh) command. Headers may be indented
differently from the left edge of the current column, have a different font size
and font style than the body of the document, and be spaced differently. The
controls that are available via the &ital(define header) command can be set
individually for each header. 
.sp
If automatic header numbering is turned on, the current paragraph for the
level is placed into the document before the header text. Figure numbers are
also affected when header numbering is enabled. When header numbering is
on. figure numbers take the form &cw(h-n) where &ital(h) is the current
header level 1 header number, and &ital(n) is the figure number within the
current header level.  The figure number is reset to 1 with each successive
header level 1 command. 

.h3 Define header properties
The define header properties command &c(dh) allows the user to establish different
properties for each of the four supported paragraph header levels. 
The user can specify the font, font size, capitalisation, whether the header level
is included in the table of contents, and spacing for a header.
The syntax of the define header properties command is shown below (broken on
multiple lines for formatting only):
.sp
.st [ &textsize 2 - ]
.sf &cwfont
.nf
	.dh level [f=font] [p=size] [s=skip]
        [i=indentr] [t={on|off}] [m=margin]
        [e={on|off}] [u={on|off}] [r=space]

.fo
.sf &textfont
.st &textsize
.sp .5
Where:
&indent
.bd .6i &ditext
.di e=on/off : When &ital(on) causes an eject to be performed prior to writing 
	the header.  If the document being written is currently in two column mode
	(more than one col defined) the eject is to the top of the next column.
.sp .4
.di level : Is the header level 1-4.
.sp .4
.di font : Is the name of the font to be used for the header level.
.sp
.di size : Is the size of the header (generally supplied in points).
.sp .4
.di skip : Is the amount of space that is to be skipped before and
	after the header. (Described in more detail below.)
.sp .4
.di indent : Is the number of characters that the first line of text
	is to be indented following headers of this level.
.sp .4
.di r=space : Defines the required space that must be available in the 
	column for the header to be written. (See section below.)
.sp .4
.di u=on/off : Causes translation of the header to uppercase characters
	if &cw(u=on) is supplied.
.sp .4
.di t=on/off : Causes the header text to be placed into the table of contents
	when set on.
.sp .4
.di margin : Is the amount of space from the start of the column that the
	header text is indented.
.sp .4
.di eject : Defines the type of eject that is performed before the header
	is placed into the document. This may be one of &cw( page, col, ) or &cw( none. )
.ed
&uindent

.sp
.gv table
Any header options that are not explicitly defined on the &ital(define header) command
remain unchanged, allowing only those attributes which do not need to be altered to
be omitted.
Table &_table lists the attribute defaults for each header level.
.sp
.if pfm
	.oe page .im headtab.im
	.sp
.ei
	.im headtab.im
.fi

.sp
.h3 Header spacing
The &ital( skip ) value used on the define header command to set the number of lines
skipped before and after the header is written.  
The parameter accepts a value which is a pair of comma separated decimal numbers which
supply the number of lines before (first value) and the number of lines following (second
value) to be skipped.
For example &cw(s=1.5,0.5) would skip the space equivalent to one and one half lines
before the header, and after the header the space equivalent to one half line 
would be added.  
If the output format does not support fractional whitespace, then the number will be 
rounded.

.h3 Header Space Minimums
To prevent a lone header at the bottom of a column, a &ital(required) space value 
may be supplied for each of the headers. 
If the required space is not available in the column, then the column is ejected
before the header is written.  
If not supplied on the define header command for a header level, the default value
is one inch.

.if false
command (s=value) has the form &cw( ba, ) where &cw(b) is the number of lines
that are skipped before the header, and &cw( a ) defines the number of lines
skipped after the header. 
If the value is &ital(21) then two lines are skipped before, and one after,
where &ital(10) would cause a blank line before the header and no blank lines
after the header.
.fi


.h2 Imbedding Source Files
Similar to the &cw(#include) statement in the C programming language, &x
allows other source files to be imbedded as the source is parsed. The
&ital(imbed) command &c(im) accepts the name of the file to include and
will open and read the named file before processing any other tokens from
the current source file.
Obvious uses for this are to reuse document source that is common to
multiple documents (glossaries, formatting macros, etc.) such that changes need
be made in the source and a global recompile performed to update all
of the documents.
.sp

Another use of the &ital(imbed) command is to cause a file to be included
at the next page break rather than at the current location.  This allows
tables, or illustrations to be placed at the top of a page rather than
at the current position either by design or when there isn't enough room
in the current column for the figure or table. 
The following source code illustrates how the
source for the &ital(get variable) command table is included and placed
at the top of the next page when generating PostScript output, but included
at that point when generating HTML output:

.** ------------------------ capture -------------------------------
.ca start imbed_examp.ca
.sp
.cc 5
.st [ &textsize 2 - ]
.sf &cwfont
.** .bx start m
.nf
     .if pfm
         .oe page .im gv_tab.im
     .ei
         .im gv_tab.im
     .fi
.fo
.sf &textfont
.st &textsize
.** .bx end
.fg Using the imbed command.
.sp 2
.ca end
.** ----------------------------------------------------------------
&ifroom(8:imbed_examp.ca)

Use like this is typical when formatting a multi-column document and
needing to insert a table which spans all of the columns and thus must
be placed at the top of the next page. 
A similar use, below, illustrates how an encapsulate postscript file
could be imbedded at the current location if there is room, but deferred
to the top of the next page if not.  The example also shows how to use
the capture command to avoid the need to manage a separate file to include.

.** ------------------------ capture -------------------------------
.ca start imbed_examp2.ca
.sp
.st [ &textsize 2 - ]
.sf &cwfont
.** .bx start m
.nf

 .ca start results_graph.ca
  .ep results.eps x=.5i l=2.5i proportional close
  .fg Results from the data
 .ca end
 .gv remain
 .** if less than 3" remain push to next page
 .if &iremain 3 <
  .oe .im results_graph.ca
 .ei
  .** enough room; get now
  .im results_graph.ca
 .fi

.fo
.sf &textfont
.st &textsize
.** .bx end
.fg Deferred imbed based on remaining space.

.ca end
.** ----------------------------------------------------------------
&ifroom(14:imbed_examp2.ca)



.h3 Imbed File Search Path
If the environment variable &cw(XFM_PATH) is defined &x will search for files listed
on the imbed command in the directories listed on the path.  If the path variable is
not defined, the file name is assumed to be in the current directory, or the necessary
part of the path of the file must be supplied.

.h2 Jump To Token
The &ital(jump) &c(jm) command causes &x to stop processing the source until
the token specified as the command parameter is found.  This provides an
easy method of excluding large amounts of the document from the final output,
and allows for &x to be used to extract document source from within files
that are not pure &x source files (e.g. &x source placed at the bottom of
C programme files which create the manual page for the function or programme.
When &x processes the C programme file, it would be instructed to skip
all of the C code until it found a token that was at the start of the
&x source code.)

.h2 Horizontal Lines
The &ital(line) &c(ln) command can be used to draw a horizontal line from the left
margin to the right edge of the current column.  
When generating a PostScript document, the width of
the line can be set using the &ital(line width) &c(lw) command.  The &ital(line)
command accepts no parameters, while the &ital(line width) command accepts the
width of the line in points.  All lines are drawn using the line size set with
the &ital(line width) command until the next &ital(line width) command is encountered.
.sp

.cc 1i
The line command accepts three optional parameters which allow the space after the line
(a=), and the left and right margins (l=, r=) to be defined. 
The following is the syntax for the line command:
.sp
.sf &cwfont
.st [ &textsize 2 - ]
.nf
 .ln [a=<dist>] [l=<dist>] [r=<dist>]
.fo
.sf &textfont
.st &textsize
.sp

The left and right margin values can be made relative to the default by prefixing the 
number with a plus (+) or minus (-) sign.

.h2 Inserting A Newline Character
When &x is generating HTML, and PostScript, the output written to the document
may be difficult to view with a standard editor. The &ital(newline) &c(nl) command
forces &x to write a newline character to the output file.  This is primarily
used when debugging an &x programme, and is &bold(not) intended to serve as a
line break command. The &ital(newline) command does not accept any parameters.

.h2 Delayed Command Execution
The execution of an &x command can be delayed until a column or page eject becomes
necessary. These commands allow an &x command to be defined and then will
execute the command after the next column or page eject. The &ital(on eject) &c(oe)
command is used to set both types of delayed command execution and has the
following syntax:
.sp
.sf &cwfont
.st [ &textsize 2 - ]
.nf
 .oe [page | all | col] command
.fo
.sf &textfont
.st &textsize
.sp

Where:
&indent
.bd .75i &ditext
.di all : If present causes the command to be executed for every eject. If not
	present, then the command is executed on the next eject type and then
	forgotten.
.sp .4
.di page : The command is added to the list to be executed at the top of the next page.
.sp .4
.di col : Causes the eject type to be set to column rather than page.
.sp .4
.di command : Are the tokens that are to be executed after the next eject.
.ed
&uindent
.sp
.gv fig
Figure &_fig illustrates an &ital(on eject) command that causes the inclusion
of a file that will create a table at the top of the next page.
If the document being generated is an HTML document, then the file is imbedded  when
this code is executed, otherwise it is placed at the top of the next page (this is
necessary as HTML documents have no concept of page or columns).

.** -----------------------------------------------------------------------
.ca start oe_examp.ca
.sp
.cc 8
.** .bx start m
.st [ &textsize 2 - ]
.sf &cwfont
.nf

        .if hfm
             .im table2.im
        .ei
             .oe col .im table2.im
        .fi

.fo
.sf &textfont
.st &textsize
.** .bx end
.fg Imbedding a table at the next page eject.
.sp 2
.ca end
.** -----------------------------------------------------------------------
&ifroom(10:oe_examp.ca)

.h2 Ejecting The Current Page
When generating PostScript documents, the &ital(page eject) &c(pa) command can
be used to cause the next formatted text to be placed at the top of the next page.
If an on eject command command has been executed to register a command, the registered
command will be executed prior to any text being added to the new page.

.h2 Page Numbering
&x will automatically number pages when page numbering has been enabled with the
&ital(page number) &c(pn) command.  
.if false
The &ital(page number) command accepts a single
keyword parameter which can be either &cw(off) or &cw(on;) when &ital(on) is given
it may optionally be followed by the page number to begin with, less one (use on 0 to 
begin numbering with page 1).
.fi

.cc 4
The page number command syntax is as follows:
.sp .5
.st [ &textsize 2 - ]
.sf &cwfont
.nf
  .pn {off| on n} [center] [noline] [roman]
       [f=fmt] [t=fmt]
.fo
.sf &textfont
.st &textsize

.sp
Where:
&indent
.bd .65i &ditext
.di on : Turns page numbering on and starts numbering on the current page with n+1.
.sp .4
.di off : Turns page numbering off.
.sp .4
.di center : Causes the page number to be centered as opposed to being written against a margin
.sp .4
.di noline : Prevents a bottom of page line from being written between the text and the bottom matter 
	running footer and/or page number.
.sp .4
.di roman : Generates the page numbers using roman numerals (lower case). Format string if supplied is ignored.
.sp .4
.di f=fmt : Format string for the page numbers written at the bottom of the page. This may be something like
	--%d-- or A-%d for numbering pages in any appendices. The default is 'Page %d'.
.sp .4
.di t=fmt : Supplies the format for the page number used in the table of contents entries. 
.ed
&uindent
.sp

Only the first &ital(%d) in a format string will be replaced with the page number.  
If it is desired to use a string with spaces as a format string, the whole parameter, including
the &cw(f=) or &cw(t=) portions, must be enclosed in backquotes.

.h2 Quitting The Compilation
The &ital(quit) &c(qu) command is used to cause &x to stop processing all input files
and to exit after generating any end of document "housekeeping" that needs to be placed
into the formatted document.
Any input after the &ital(quit) command is ignored. This command accepts no parameters.

.h2 Running Headers and Footers
Running headers and footers are placed at the top and bottom of each page when generating
PostScript output.  The &ital(running header) &c(rh) and &ital(running footer)
&c(rf) commands accept all tokens to the end of the current record as the header or footer
string to be used.
When a running header or footer has been defined it is separated from the rest of the document
text with a solid horizontal line. 
When two sided mode has been selected, the running matter is placed such that the strings
"edge" on the right side of the page for odd pages, and on the left side of the page for
even pages.
.sp
The font size of the headers, footers, and page number strings can be set with the
&ital(running size) &c(rs) command. This command accepts a value (in points) to be used,
and until a &ital(running size) command is encountered, the default value of 10 points is assumed.

.if false
.h2 The Section Command
When generating RTF documents it is necessary to mark document sections in order to change the
running header and footer text. The &ital(section) &c(sc) command is used to do this and takes
no parameters.  Assuming that a header level one causes a page eject, the &ital(section) command
should be placed just prior to the &ital(running header) and/or &ital(running footer) commands
and the header level one command.  This ordering is necessary to force the RTF interpreter to
begin including the new running matter strings with the next page eject. The following
illustrates this concept:
.sp
.cc 8
.** .bx start m
.st [ &textsize 2 - ]
.sf &cwfont
.nf
  .sc
  .rh Overview
  .h1 Introduction and Overview

.fo
.sf &textfont
.st &textsize
.fg Illustrating the section command.
.sp
.fi

.h3 Running header placement
The running header is placed above the text using the value of the &ital( top gutter ) value.
The gutter can be set using the &c(tg) which accepts a value setting the distance above the top
margin in either points or inches.
The value must be less than the current top margin value, or it will not be reset; it is wise to set
the top margin value first to ensure that they are both properly set. 
When generating HTML, or if running headers are not being used, the top gutter value has no meaning.
The following illustrates the setting of the top margin to one inch, and the gutter to 4 tenths of an inch.
.sp .5
.cc 8
.sf &cwfont
.st [ &textsize 2 - ]
.nf
  .tm 1i
  .tg .4i
.fo
.sf &textfont
.st &textsize
.fg Illustrating the top margin and top gutter commands.
.sp
.fi



.h2 Setting The Space Between Lines
When generating PostScript documents, the amount of space
between text lines can be controlled using the &ital(set linespace) &c(sl)
command. This command accepts the number of points that the user wishes
to have between each line of formatted text. Until the user resets the
linespace value, the default of three (3) points is used.

.h2 Inserting Blank Lines
The &ital(space) &c(sp) command is used to insert blank lines into the document.
When the &ital(space) command is encountered, the formatting of the current line is
terminated and its contents are flushed to the output file.
The current &cw(y) position is adjusted such that the next text line will be
separated from the previous by the requested number of blank lines.
.sp

The command accepts an optional parameter which is the number of blank lines to insert. 
If the parameter is missing, then one (1) is assumed.  (While the parameter is optional,
it is recommended that the &ital(space) command always be given a parameter.) When generating
HTML output, &xfm will insert the requested number of "paragraph" tags into the document
which would logically cause multiple blank lines to be placed into the document, however
most HTML browsers ignore sequential paragraph tags.

.h3 Partial Space
.ix force `partial space`
The &ital(space) command can be  given a fractional value, e.g. .5 or 1.5, to insert
a blank line using the value as a multiplier. 
This allows a more fine grained control over vertical space when it is needed.


.h3 Space Distance
The distance that is computed when the &ital(space) command is encountered is based on the
current font size. 
Changing the font size immediately before using the &ital(space) command will affect the
space inserted for each blank line.

.h2 Setting The Y Position
The &cw(y) position (the number of points the current line is placed from the top of the page)
can be controlled when generating PostScript output. The &ital(set y) &c(sy) command
accepts as a parameter the number of points that the current &cw(y) value should be set to.
A relative distance can also be indicated by using either a plus (+) or minus (-) sign
to indicate movement relative to the current &cw(y) position on the page.
A positive value indicates towards the bottom of the page, and a negative value indicates towards the top.

.h2 Generating A Table Of Contents
A table of contents will automatically be generated by &x if the &ital(table of contents) &c(tc)
command is used with a parameter of &cw(on.) &x creates the table of contents by writing the
header text strings, for header levels that define the table of contents option in a
&ital(definition header) command, along with the header number (if header numbering is enabled)
and the page number that the header was placed on. The file that is created is &x source code
that can then be read and processed by &x to create the table of contents.  The name of the file
created is the same as the input file with the extension replaced with &cw(.toc.)

.sp

.gv fig
.dv tcfig &_fig
.** ----------------------------------------------------------------------------
.ca start toc_examp.ca
.cc 12
.** .bx start m
.st [ &textsize 2 - ]
.sf &cwfont
.nf

      .if second_pass
          .tc off
          .im cover.im
          .im document.toc
          .pa
      .ei
          .tc on
      .fi
      .pn 1

.fo
.** .bx end
.sf &textfont
.st &textsize
.fg Automatic inclusion of table of contents
.sp 2
.ca end
.** ----------------------------------------------------------------------------
&ifroom(15:toc_examp.ca)


To include the table of contents as a part of the formatted document &x must be invoked twice across
the document source, and enough information provided to the source to know what to do.
Figure &tcfig contains  a snipit of &x code that will include the table of contents source during the
second pass, and properly set the page numbers.
This assumes that the &cw(second_pass) variable has been set.

The following lines of shell code illustrate one method of how this can be done.
.sp

.** ---------------------------------------------------------------------------
.ca start twopass_examp.ca
.cc 8
.st [ &textsize 2 - ]
.sf &cwfont
.** .bx start m
.nf

 # first pass just generate uguide.toc
 # second pass generates postscript output
 # with toc added

 pfm uguide.xfm /dev/null
 pfm uguide.xfm uguide.ps .dv second_pass 1 :

.fo
.** .bx end
.sf &textfont
.st &textsize
.fg Shell commands to generate a document with table of contents.
.sp 2
.ca end
.** ---------------------------------------------------------------------------
&ifroom(15:twopass_examp.ca)

.h2 Setting The Top Margin
The amount of white space between the top of the page and the first line of text can be controlled
using the &ital(top margin) &c(tm) command. The command accepts a distance value as its only
parameter and will set the top margin to this value upon the next column eject.  A temporary
top margin can be established using the &ital(temporary top) &c(tt) command.  This command also
accepts an optional  distance parameter, and will set the top margin to the the distance provided,
or to the current &cw(y) position  if the parameter is omitted.  This temporary margin is applied to
all columns on the current page and is forgotten after the next page eject.  The &ital(temporary top)
command is generally used after placing a table, which spans the entire page width, at the
top of the page and wanting the subsequent columns to format nicely underneath it.
.sp

.h2 Two Sided Page Mode
The &ital(two sided) &c(ts) command causes &x to place running headers, footers, and page numbers
at the right edge of odd numbered pages, and at the left edge of even numbered pages. The
assumption is that when the document is printed, the running matter is easily seen as the
reader flips the pages whether flipping from the beginning of the document or from the back.
When formatting a document to be viewed on line, two sided page mode should not be used as it
will not have a pleasing effect. When generating HTML documents this command is ignored.
The command accepts no parameters.


.h2 Debugging
There are times that the output generated by &x is not what was expected.
Usually this is because the document source has a 'programming error' which has caused the
problem.
In most cases, careful examination of the document source will uncover the problem which
can be corrected and the expected results obtained.
Sometimes a bit more debugging information is desired to assist with this process.
The &ital(trace) &c(xx) command allows the user to turn on executing tracing for some or all
of the document processing.
The &ital(trace) command accepts a numeric parameter which sets the amount of information that
is written to the standard error device.
A value of zero (0) turns tracing off.
